// src/utils/permitSignature.ts
// ERC-2612 Permit ã‚·ã‚°ãƒãƒãƒ£ç”Ÿæˆãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£

import { ethers } from 'ethers';

/**
 * ERC-2612 Permitç”¨ã®EIP-712ãƒ‰ãƒ¡ã‚¤ãƒ³
 */
export interface PermitDomain {
  name: string;
  version: string;
  chainId: number;
  verifyingContract: string;
}

/**
 * Permitãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å‹å®šç¾©
 */
export interface PermitMessage {
  owner: string;
  spender: string;
  value: string;
  nonce: number;
  deadline: number;
}

/**
 * EIP-712å‹å®šç¾©
 */
const PERMIT_TYPES = {
  Permit: [
    { name: 'owner', type: 'address' },
    { name: 'spender', type: 'address' },
    { name: 'value', type: 'uint256' },
    { name: 'nonce', type: 'uint256' },
    { name: 'deadline', type: 'uint256' },
  ],
};

/**
 * JPYCãƒˆãƒ¼ã‚¯ãƒ³ã®nonceï¼ˆã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ï¼‰ã‚’å–å¾—
 * @param tokenAddress JPYCãƒˆãƒ¼ã‚¯ãƒ³ã‚¢ãƒ‰ãƒ¬ã‚¹
 * @param ownerAddress ã‚ªãƒ¼ãƒŠãƒ¼ã‚¢ãƒ‰ãƒ¬ã‚¹
 * @param provider ethersãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼
 * @returns ç¾åœ¨ã®nonce
 */
export async function getPermitNonce(
  tokenAddress: string,
  ownerAddress: string,
  provider: ethers.providers.Provider
): Promise<number> {
  const tokenContract = new ethers.Contract(
    tokenAddress,
    ['function nonces(address owner) view returns (uint256)'],
    provider
  );

  const nonce = await tokenContract.nonces(ownerAddress);
  return nonce.toNumber();
}

/**
 * ERC-2612 Permitã‚·ã‚°ãƒãƒãƒ£ã‚’ç”Ÿæˆ
 * @param signer ethers Signerï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚¦ã‚©ãƒ¬ãƒƒãƒˆï¼‰
 * @param tokenAddress JPYCãƒˆãƒ¼ã‚¯ãƒ³ã‚¢ãƒ‰ãƒ¬ã‚¹
 * @param spenderAddress æ‰¿èªå…ˆã‚¢ãƒ‰ãƒ¬ã‚¹ï¼ˆPaymentGatewayï¼‰
 * @param amount æ‰¿èªé‡‘é¡ï¼ˆweiå˜ä½ã®æ–‡å­—åˆ—ï¼‰
 * @param deadline æœ‰åŠ¹æœŸé™ï¼ˆUnix timestampï¼‰
 * @param chainId ãƒã‚§ãƒ¼ãƒ³IDï¼ˆ137 = Polygon Mainnetï¼‰
 * @returns Permitã‚·ã‚°ãƒãƒãƒ£ {v, r, s, deadline, nonce}
 */
export async function signPermit(
  signer: ethers.Signer,
  tokenAddress: string,
  spenderAddress: string,
  amount: string,
  deadline: number,
  chainId: number = 137
): Promise<{ v: number; r: string; s: string; deadline: number; nonce: number }> {
  const ownerAddress = await signer.getAddress();

  // 1. ãƒˆãƒ¼ã‚¯ãƒ³ã®nonceã‚’å–å¾—
  const provider = signer.provider;
  if (!provider) {
    throw new Error('Signer must have a provider');
  }

  const nonce = await getPermitNonce(tokenAddress, ownerAddress, provider);

  // 2. EIP-712ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚’å®šç¾©
  const domain: PermitDomain = {
    name: 'JPY Coin', // JPYCã®ãƒˆãƒ¼ã‚¯ãƒ³å
    version: '1',
    chainId: chainId,
    verifyingContract: tokenAddress,
  };

  // 3. Permitãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ä½œæˆ
  const message: PermitMessage = {
    owner: ownerAddress,
    spender: spenderAddress,
    value: amount,
    nonce: nonce,
    deadline: deadline,
  };

  console.log('ğŸ“ Permitç½²åãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿:', {
    domain,
    message,
  });

  // 4. EIP-712ç½²åã‚’ç”Ÿæˆ
  const signature = await signer._signTypedData(domain, PERMIT_TYPES, message);

  // 5. ã‚·ã‚°ãƒãƒãƒ£ã‚’ v, r, s ã«åˆ†è§£
  const sig = ethers.utils.splitSignature(signature);

  console.log('âœ… Permitç½²åæˆåŠŸ:', {
    v: sig.v,
    r: sig.r,
    s: sig.s,
    nonce,
    deadline,
  });

  return {
    v: sig.v,
    r: sig.r,
    s: sig.s,
    deadline,
    nonce,
  };
}

/**
 * Permitã‚·ã‚°ãƒãƒãƒ£ã®æœ‰åŠ¹æœŸé™ã‚’è¨ˆç®—ï¼ˆç¾åœ¨æ™‚åˆ» + æŒ‡å®šåˆ†æ•°ï¼‰
 * @param minutesFromNow ç¾åœ¨æ™‚åˆ»ã‹ã‚‰ä½•åˆ†å¾Œã‹
 * @returns Unix timestampï¼ˆç§’å˜ä½ï¼‰
 */
export function getPermitDeadline(minutesFromNow: number = 30): number {
  return Math.floor(Date.now() / 1000) + minutesFromNow * 60;
}

/**
 * Permitã‚·ã‚°ãƒãƒãƒ£ã®æ¤œè¨¼ï¼ˆã‚ªãƒ•ãƒã‚§ãƒ¼ãƒ³ï¼‰
 * @param signature Permitã‚·ã‚°ãƒãƒãƒ£
 * @param domain EIP-712ãƒ‰ãƒ¡ã‚¤ãƒ³
 * @param message Permitãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
 * @param expectedSigner æœŸå¾…ã•ã‚Œã‚‹ç½²åè€…ã‚¢ãƒ‰ãƒ¬ã‚¹
 * @returns æ¤œè¨¼çµæœï¼ˆtrue = æœ‰åŠ¹ï¼‰
 */
export function verifyPermitSignature(
  signature: { v: number; r: string; s: string },
  domain: PermitDomain,
  message: PermitMessage,
  expectedSigner: string
): boolean {
  try {
    const digest = ethers.utils._TypedDataEncoder.hash(domain, PERMIT_TYPES, message);
    const recoveredAddress = ethers.utils.recoverAddress(digest, signature);

    return recoveredAddress.toLowerCase() === expectedSigner.toLowerCase();
  } catch (error) {
    console.error('âŒ Permitç½²åæ¤œè¨¼ã‚¨ãƒ©ãƒ¼:', error);
    return false;
  }
}

/**
 * PaymentGatewayã®executePaymentWithPermitç”¨ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æº–å‚™
 * @param signer ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®Signer
 * @param paymentGatewayAddress PaymentGatewayã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹
 * @param jpycAddress JPYCãƒˆãƒ¼ã‚¯ãƒ³ã‚¢ãƒ‰ãƒ¬ã‚¹
 * @param merchantAddress å—å–äººã‚¢ãƒ‰ãƒ¬ã‚¹
 * @param amount æ”¯æ‰•ã„é‡‘é¡ï¼ˆweiå˜ä½ï¼‰
 * @param requestId ãƒªã‚¯ã‚¨ã‚¹ãƒˆIDï¼ˆbytes32å½¢å¼ï¼‰
 * @param expiryMinutes Permitæœ‰åŠ¹æœŸé™ï¼ˆåˆ†ï¼‰
 * @returns executePaymentWithPermitã®å…¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
 */
export async function preparePermitPaymentParams(
  signer: ethers.Signer,
  paymentGatewayAddress: string,
  jpycAddress: string,
  merchantAddress: string,
  amount: string,
  requestId: string,
  expiryMinutes: number = 30
): Promise<{
  requestId: string;
  merchant: string;
  amount: string;
  deadline: number;
  v: number;
  r: string;
  s: string;
}> {
  // 1. Permitæœ‰åŠ¹æœŸé™ã‚’è¨ˆç®—
  const deadline = getPermitDeadline(expiryMinutes);

  // 2. Permitã‚·ã‚°ãƒãƒãƒ£ã‚’ç”Ÿæˆ
  const permitSig = await signPermit(
    signer,
    jpycAddress,
    paymentGatewayAddress, // spender = PaymentGateway
    amount,
    deadline,
    137 // Polygon Mainnet
  );

  // 3. requestIdã‚’bytes32å½¢å¼ã«å¤‰æ›ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
  let requestIdBytes32 = requestId;
  if (!requestId.startsWith('0x')) {
    // æ–‡å­—åˆ—ã‚’bytes32ã«å¤‰æ›
    requestIdBytes32 = ethers.utils.id(requestId);
  }

  return {
    requestId: requestIdBytes32,
    merchant: merchantAddress,
    amount: amount,
    deadline: permitSig.deadline,
    v: permitSig.v,
    r: permitSig.r,
    s: permitSig.s,
  };
}
